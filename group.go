// Package group manages a collection of cancellable goroutines.
//
package group

import "sync"

// A Task is a function that performs some arbitrary task and returns an error
// value, and is the basic unit of work in a Group.
type Task func() error

// A Group represents a collection of cooperating goroutines.  New tasks can be
// added to the group via the Go method.
//
// Any error returned by a task is passed to the callback function provided
// when the Group was constructed.  The callback can use this to log errors or
// cancel the work.  All calls to the callback come from a single goroutine.
//
// Basic usage example:
//   ctx, cancel := context.WithCancel(ctx)
//   g := group.New(group.OnError(func(error) { cancel() }))
//   g.Go(f1)
//   g.Go(f2)
//   ...
//   if err := g.Wait(); err != nil {
//     log.Printf("An error occurred: %v", err)
//   }
//
type Group struct {
	onError func(error)    // called each time a task returns non-nil
	wg      sync.WaitGroup // counter for active goroutines

	gather *sync.Once    // setup for error collector
	errc   chan<- error  // errors generated by goroutines
	edone  chan struct{} // signals error completion
	err    error         // error returned from Wait
}

// New constructs a new, empty group.  Add tasks to the group using g.Go.  Wait
// for the group to complete with g.Wait.
func New(opts ...Option) *Group {
	g := &Group{onError: func(error) {}, gather: new(sync.Once)}
	for _, opt := range opts {
		opt(g)
	}
	return g
}

// Go adds a new task to the group.
func (g *Group) Go(task Task) {
	g.wg.Add(1)

	// The first time a task is added to an otherwise clear group, set up the
	// error collector goroutine.  We don't do this in the constructor so that
	// an unused group can be abandoned without orphaning a goroutine.
	g.gather.Do(func() {
		errc := make(chan error)
		g.err = nil
		g.errc = errc
		g.edone = make(chan struct{})
		go func() {
			defer close(g.edone)
			for err := range errc {
				if g.err == nil {
					g.err = err // capture the first error always
				}
				g.onError(err)
			}
		}()
	})
	go func() {
		defer g.wg.Done()
		if err := task(); err != nil {
			g.errc <- err
		}
	}()
}

// StartN starts n separate goroutines running task in g.
func (g *Group) StartN(n int, task Task) {
	for n > 0 {
		g.Go(task)
		n--
	}
}

// Wait blocks until all the goroutines currently active in the group have
// returned, and all reported errors have been delivered to the callback.
// Wait returns the first non-nil error returned by any of the goroutines
// in the group.
func (g *Group) Wait() error {
	g.wg.Wait()
	if g.errc != nil {
		close(g.errc)
		<-g.edone
		g.errc = nil
		g.gather = new(sync.Once)
	}
	return g.err
}

// An Option specifies a configurable option for a Group.
type Option func(*Group)

// OnError returns an Option that provides a function to be invoked each time a
// task in the group returns a non-nil error.  The error value from the task is
// passed to f.  All calls to f are made from a single goroutine, so it is safe
// for f to access a resource under its control without further locking.
func OnError(f func(error)) Option {
	if f == nil {
		return func(*Group) {} // do nothing
	}
	return func(g *Group) { g.onError = f }
}

// Capacity returns a function that starts each task passed to it in g,
// allowing no more than n tasks to be active concurrently.
func Capacity(g *Group, n int) func(Task) {
	adm := make(chan struct{}, n)
	return func(task Task) {
		g.Go(func() error {
			adm <- struct{}{}
			err := task()
			<-adm
			return err
		})
	}
}
