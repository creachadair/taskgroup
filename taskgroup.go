// Package taskgroup manages a collection of cooperating goroutines.  It
// simplifies common concerns of waiting for goroutine termination and
// collecting errors.
package taskgroup

import "sync"

// A Task is a function that performs some arbitrary task and returns an error
// value, and is the basic unit of work in a Group.
type Task func() error

// A Group manages a collection of cooperating goroutines.  New tasks can be
// added to the group via the Go method.  The caller can wait for the tasks to
// complete by calling the Wait method.
//
// The group collects any errors returned by the tasks in the group. The first
// non-nil error reported by any task (and not otherwise filtered) is returned
// from the Wait method.
type Group struct {
	onError func(error) error // called each time a task returns non-nil
	wg      sync.WaitGroup    // counter for active goroutines

	setup *sync.Once    // setup for error collector
	errc  chan<- error  // errors generated by goroutines
	edone chan struct{} // signals error completion
	err   error         // error returned from Wait
}

// New constructs a new, empty group.  Add tasks to the group using g.Go.  Wait
// for the group to complete with g.Wait.  If ef != nil, it is called each time
// a task reports an error.  The error returned by the ErrorFunc replaces the
// task's error.
func New(ef ErrorFunc) *Group {
	if ef == nil {
		ef = func(e error) error { return e }
	}
	return &Group{setup: new(sync.Once), onError: ef}
}

// Go adds a new task to the group, and returns g to permit chaining.
func (g *Group) Go(task Task) *Group {
	g.wg.Add(1)
	g.init()
	errc := g.errc
	go func() {
		defer g.wg.Done()
		if err := task(); err != nil {
			errc <- err
		}
	}()
	return g
}

func (g *Group) init() {
	// The first time a task is added to an otherwise clear group, set up the
	// error collector goroutine.  We don't do this in the constructor so that
	// an unused group can be abandoned without orphaning a goroutine.
	g.setup.Do(func() {
		errc := make(chan error)
		g.err = nil
		g.errc = errc
		g.edone = make(chan struct{})
		go func() {
			defer close(g.edone)
			for err := range errc {
				if e := g.onError(err); e != nil {
					if g.err == nil {
						g.err = e // capture the first error always
					}
				}
			}
		}()
	})
}

// Wait blocks until all the goroutines currently active in the group have
// returned, and all reported errors have been delivered to the callback.  Wait
// returns the first non-nil error returned by any of the goroutines in the
// group and not filtered by an ErrorFunc.
//
// After a call to Wait returns, the group is ready for reuse.
func (g *Group) Wait() error {
	g.wg.Wait()
	if g.errc != nil {
		close(g.errc)
		<-g.edone
		g.errc = nil
		g.setup = new(sync.Once)
	}
	return g.err
}

// An ErrorFunc is called by a group each time a task reports an error.  Its
// return value replaces the reported error, so the ErrorFunc can filter or
// suppress errors by modifying or discarding the input error.
type ErrorFunc func(error) error

// Trigger adapts f to an ErrorFunc. The resulting function returns task errors
// unmodified.
func Trigger(f func()) ErrorFunc { return func(e error) error { f(); return e } }

// Listen adapts f to an ErrorFunc. The resulting function returns task errors
// unmodified.
func Listen(f func(error)) ErrorFunc { return func(e error) error { f(e); return e } }

// Limit returns g and a function that starts each task passed to it in g,
// allowing no more than n tasks to be active concurrently.  If n â‰¤ 0, the
// start function is equivalent to g.Go, which enforces no limit.
func (g *Group) Limit(n int) (*Group, func(Task) *Group) {
	if n <= 0 {
		return g, g.Go
	}
	adm := make(chan struct{}, n)
	return g, func(task Task) *Group {
		adm <- struct{}{}
		return g.Go(func() error {
			defer func() { <-adm }()
			return task()
		})
	}
}
